\chapter{Target Details}
\label{target-details}

\section{Javascript}
\label{target-javascript}
\state{NoContent}

\subsection{Getting started with Javascript}
\label{target-javascript-getting-started}

Developing Javascript applications is really powerful with Haxe. Let's see our first sample.
This is a very simple example showing most of the toolchain. 

Create a new folder, save this class as \ic{Main.hx}.

\begin{lstlisting}
import js.Lib;
import js.Browser;
class Test {
    static function main() {
        var button = Browser.document.createButtonElement();
        button.textContent = "Click me!";
        button.onclick = function(event) {
            Lib.alert("Haxe is great");
        }
        Browser.document.body.appendChild(button);
    }
}
\end{lstlisting}

To compile, you can run this from the command line:

\begin{lstlisting}
haxe -js main-javascript.js -main Main -D js-flatten -dce full
\end{lstlisting}

.. or create and run (double-click) a file called \ic{compile.hxml}. In this example the hxml-file should be in the same directory as the example class.

\begin{lstlisting}
-js main-javascript.js
-main Main
-D js-flatten
-dce full
\end{lstlisting}

The output will be a main-javascript.js, which creates and adds clickable button to the document body.

\paragraph{Run the Javascript}

To display the output in a javascript-enabled browser, you need to create a html-document called \ic{index.html} and open it.

\begin{lstlisting}
<!DOCTYPE html>
<html>
	<body>
		<script src="main-javascript.js">
	</body>
</html>
\end{lstlisting}

\paragraph{Differences}

The \tref{standard classes}{std} such as \type{Date}, \type{Array}, \type{String} can have some changes in Haxe since they are common to all Haxe platforms. 
The \ic{XML} and \ic{XMLNode} classes are merged into one single \type{Xml} class, and provides and extended API.

Apart from these minor differences, you can use the existing Javascript API if you know it already. 
You can read the more about the Javascript documentation in the \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript}{MDN}.


\subsection{Loading extern classes using "require" function}
\label{target-javascript-require}
\since{3.2.0}

Modern \target{JavaScript} platforms, such as Node.js provide a way of loading objects
from external modules using the "require" function. Haxe supports automatic generation
of "require" statements for \expr{extern} classes.

This feature can be enabled by specifying \expr{@:jsRequire} metadata for the extern class. If our \expr{extern} class represents a whole module, we pass a single argument to the \expr{@:jsRequire} metadata specifying the name of the module to load:

\haxe{assets/JSRequireModule.hx}

In case our \expr{extern} class represents an object within a module, second \expr{@:jsRequire} argument specifies an object to load from a module:

\haxe{assets/JSRequireObject.hx}

The second argument is a dotted-path, so we can load sub-objects in any hierarchy.

If we need to load custom JavaScript objects in runtime, a \expr{js.Lib.require} function can be used. It takes \expr{String} as its only argument and returns \expr{Dynamic}, so it is advised to be assigned to a strictly typed variable.

\section{Flash}
\label{target-flash}

\section{Neko}
\label{target-neko}

\section{PHP}
\label{target-php}

\section{C++}
\label{target-cpp}

\subsection{Using C++ Defines}
\label{target-cpp-defines}
\begin{itemize}
	\item ANDROID_HOST
	\item ANDROID_NDK_DIR
	\item ANDROID_NDK_ROOT
	\item BINDIR
	\item DEVELOPER_DIR
	\item HXCPP
	\item HXCPP_32
	\item HXCPP_COMPILE_CACHE
	\item HXCPP_COMPILE_THREADS
	\item HXCPP_CONFIG
	\item HXCPP_CYGWIN
	\item HXCPP_DEPENDS_OK
	\item HXCPP_EXIT_ON_ERROR
	\item HXCPP_FORCE_PDB_SERVER
	\item HXCPP_M32
	\item HXCPP_M64
	\item HXCPP_MINGW
	\item HXCPP_MSVC
	\item HXCPP_MSVC_CUSTOM
	\item HXCPP_MSVC_VER
	\item HXCPP_NO_COLOR
	\item HXCPP_NO_COLOUR
	\item HXCPP_VERBOSE
	\item HXCPP_WINXP_COMPAT
	\item IPHONE_VER
	\item LEGACY_MACOSX_SDK
	\item LEGACY_XCODE_LOCATION
	\item MACOSX_VER
	\item MSVC_VER
	\item NDKV
	\item NO_AUTO_MSVC
	\item PLATFORM
	\item QNX_HOST
	\item QNX_TARGET
	\item TOOLCHAIN_VERSION
	\item USE_GCC_FILETYPES
	\item USE_PRECOMPILED_HEADERS
	\item android
	\item apple
	\item blackberry
	\item cygwin
	\item dll_import
	\item dll_import_include
	\item dll_import_link
	\item emcc
	\item emscripten
	\item gph
	\item hardfp
	\item haxe_ver
	\item ios
	\item iphone
	\item iphoneos
	\item iphonesim
	\item linux
	\item linux_host
	\item mac_host
	\item macos
	\item mingw
	\item rpi
	\item simulator
	\item tizen
	\item toolchain
	\item webos
	\item windows
	\item windows_host
	\item winrt
	\item xcompile
\end{itemize}

\subsection{Using C++ Pointers}
\label{target-cpp-pointers}

\section{Java}
\label{target-java}

\section{C\#}
\label{target-cs}
