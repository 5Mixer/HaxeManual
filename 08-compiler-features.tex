\chapter{Compiler Features}
\label{cr-features}
\state{NoContent}

\section{Built-in Compiler Metadata}
\label{cr-metadata}

Starting from Haxe 3.0, you can get the list of defined compiler metadata by running \expr{haxe --help-metas}

\begin{center}
\begin{tabular}{| l | l | l |}
	\hline
	\multicolumn{3}{|c|}{Global metatags} \\ \hline
	Metatag &  Description  &  Platform \\ \hline
	@:abstract &  Sets the underlying class implementation as \tref{abstract type}{types-abstract}  &  cs  java \\
	@:access \_(Target path)\_  &   Forces private access to package  type or field  see \tref{Access Control}{lf-access-control}  &  all \\
	@:allow \_(Target path)\_  &   Allows private access from package  typeor field  see \tref{Access Control}{lf-access-control}  &  all \\
	@:annotation  &  Annotation (\expr{@interface}) definitions on \expr{-java-lib} imports will be annotated with this metadata. Has no effect on types compiled by Haxe   &  java \\
	@:arrayAccess  &  Allows \tref{Array access}{types-abstract-array-access} on an abstract  &  all \\
	@:autoBuild \_(Build macro call)\_  &   Extends \expr{@:build} metadata to all extending and implementing classes. See \tref{Macro autobuild}{macro-auto-build}  &  all \\
	@:bind  &  Override Swf class declaration  &  flash \\
	@:bitmap \_(Bitmap file path)\_  &  \_Embeds given bitmap data into the class (must extend \expr{flash.display.BitmapData})   &  flash \\
	@:build \_(Build macro call)\_  &   Builds a class or enum from a macro. See \tref{Type Building}{macro-type-building}  &  all \\
	@:buildXml  &    &  cpp \\
	@:classCode  &  Used to inject platform-native code into a class  &  cs  java \\
	@:commutative  &  Declares an abstract operator as commutative  &  all \\
	@:compilerGenerated  &  Marks a field as generated by the compiler. Shouldn't be used by the end user  &  cs  java \\
	@:coreApi &  Identifies this class as a core api class (forces Api check)  &  all \\
	@:coreType  &  Identifies an abstract as \tref{core type}{types-abstract-core-type} so that it requires no implementation  &  all \\
	@:cppFileCode  &     &  cpp \\
	@:cppNamespaceCode  &    &  cpp \\
	@:dce  &  Forces \tref{Dead Code Elimination}{cr-dce} even when not \expr{-dce full} is specified  &  all \\
	@:debug  &  Forces debug information to be generated into the Swf even without \expr{-debug}   &  flash \\
	@:decl   &     &  cpp \\
	@:defParam  &    &  all \\
	@:delegate  &  Automatically added by \expr{-net-lib} on delegates   &  cs \\
	@:depend  &     &  cpp \\
	@:deprecated   &  Automatically added by \expr{-java-lib} on class fields annotated with \expr{@Deprecated} annotation. Has no effect on types compiled by Haxe. \_  &  java \\
	@:event  &  Automatically added by \expr{-net-lib} on events. Has no effect on types compiled by Haxe.   &  cs \\
	@:enum  &  Defines finite value sets to abstract definitions. See \tref{enum abstracts}{types-abstract-enum}  &  all \\
	@:expose \_(?Name=Class path)\_  &  Makes the class available on the \expr{window} object   &  js \\
	@:extern  &  Marks the field as extern so it is not generated  &  all \\
	@:fakeEnum \_(Type name)\_  &  Treat enum as collection of values of the specified type  &  all \\
	@:file(File path)  &  Includes a given binary file into the target Swf and associates it with the class (must extend \expr{flash.utils.ByteArray})  &  flash \\
	@:final  &  Prevents a class from being extended  &  all \\
	@:font \_(TTF path Range String)\_  &  Embeds the given TrueType font into the class (must extend \expr{flash.text.Font})  &  flash \\
	@:forward \_(List of field names)\_  &  \tref{Forwards field access}{types-abstract-forward} to underlying type  &  all \\
	@:from   &  Specifies that the field of the abstract is a cast operation from the type identified in the function. See \tref{Implicit Casts}{types-abstract-implicit-casts}  &  all \\
	@:functionCode  &     &  cpp \\
	@:functionTailCode  &    &  cpp \\
	@:generic &  Marks a class or class field as \tref{generic}{type-system-generic} so each type parameter combination generates its own type/field  &  all \\
	@:genericBuild  &  Builds instances of a type using the specified macro   &  all \\
	@:getter \_(Class field name)\_  &  Generates a native getter function on the given field   &  flash \\
	@:hack   &  Allows extending classes marked as \expr{@:final}  &  all \\
	@:headerClassCode  &    &  cpp \\
	@:headerCode   &     &  cpp \\
	@:headerNamespaceCode  &    &  cpp \\
	@:hxGen  &  Annotates that an extern class was generated by Haxe  &  cs  java \\
	@:ifFeature \_(Feature name)\_  &  Causes a field to be kept by \tref{DCE}{cr-dce} if the given feature is part of the compilation  &  all \\
	@:include &     &  cpp \\
	@:initPackage  &    &  all \\
	@:internal  &  Generates the annotated field/class with \expr{internal} access  &  cs  java \\
	@:isVar  &  Forces a physical field to be generated for properties that otherwise would not require one  &  all \\
	@:keep   &  Causes a field or type to be kept by \tref{DCE}{cr-dce}  &  all \\
	@:keepInit  &  Causes a class to be kept by \tref{DCE}{cr-dce} even if all its field are removed  &  all \\
	@:keepSub &  Extends \expr{@:keep} metadata to all implementing and extending classes  &  all \\
	@:macro  &  \_(deprecated)\_  &  all \\
	@:meta   &  Internally used to mark a class field as being the metadata field  &  all \\
	@:multiType \_(Relevant type parameters)\_  &  Specifies that an abstract chooses its this-type from its \expr{@:to} functions  &  all \\
	@:native \_(Output type path)\_  &  Rewrites the path of a class or enum during generation  &  all \\
	@:nativeGen  &  Annotates that a type should be treated as if it were an extern definition - platform native  &  cs  java \\
	@:noCompletion  &  Prevents the compiler from suggesting \tref{completion}{cr-completion} on this field  &  all \\
	@:noDebug &  Does not generate debug information into the Swf even if \expr{-debug} is set   &  flash \\
	@:noDoc  &  Prevents a type from being included in documentation generation  &  all \\
	@:noImportGlobal  &  Prevents a static field from being imported with \expr{import Class.*}  &  all \\
	@:noPackageRestrict  &    &  all \\
	@:noStack &     &  cpp \\
	@:noUsing &  Prevents a field from being used with \expr{using}  &  all \\
	@:notNull &  Declares an abstract type as not accepting \tref{\expr{null} values}{types-nullability}  &  all \\
	@:ns  &  Internally used by the Swf generator to handle namespaces   &  flash \\
	@:op \_(The operation)\_  &   Declares an abstract field as being an \tref{operator overload}{types-abstract-operator-overloading}  &  all \\
	@:optional  &  Marks the field of a structure as optional. See \tref{Optional Arguments}{types-nullability-optional-arguments}  &  all \\
	@:overload \_(Function specification)\_  &  Allows the field to be called with different argument types. Function specification cannot be an expression.  &  all \\
	@:privateAccess  &  Allow private access to anything for the annotated expression  &  all \\
	@:property  &  Marks a property field to be compiled as a native C\# property   &  cs \\
	@:protected  &  Marks a class field as being protected  &  all \\
	@:public  &  Marks a class field as being public  &  all \\
	@:publicFields  &  Forces all class fields of inheriting classes to be public  &  all \\
	@:readOnly  &  Generates a field with the \expr{readonly} native keyword   &  cs \\
	@:remove  &  Causes an interface to be removed from all implementing classes before generation  &  all \\
	@:require \_(Compiler flag to check)\_  &  Allows access to a field only if the specified \tref{compiler flag}{lf-condition-compilation} is set  &  all \\
	@:rtti   &  Adds runtime type informations. See \tref{RTTI}{cr-rtti}  &  all \\
	@:runtime  &    &  all \\
	@:runtimeValue  &  Marks an abstract as being a runtime value  &  all \\
	@:setter \_(Class field name)\_  &  Generates a native getter function on the given field   &  flash \\
	@:sound \_(File path)\_  &  Includes a given \_.wav\_ or \_.mp3\_ file into the target Swf and associates it with the class (must extend \expr{flash.media.Sound})  &  flash \\
	@:struct  &  Marks a class definition as a struct.   &  cs \\
	@:suppressWarnings  &  Adds a SuppressWarnings annotation for the generated Java class  &  java \\
	@:throws \_(Type as String)\_  &  Adds a \expr{throws} declaration to the generated function.   &  java \\
	@:to  &  Specifies that the field of the abstract is a cast operation to the type identified in the function. See \tref{Implicit Casts}{types-abstract-implicit-casts} & ~ \\
	@:transient  &  Adds the \expr{transient} flag to the class field  &  java \\
	@:unbound  &  Compiler internal to denote unbounded global variable  &  all \\
	@:unifyMinDynamic  &  Allows a collection of types to unify to Dynamic  &  all \\
	@:unreflective  &    &  cpp \\
	@:unsafe  &  Declares a class  or a method with the C\#'s \expr{unsafe} flag   &  cs \\
	@:usage  &    &  all \\
	@:volatile  &    &  cs  java \\
\end{tabular}
\end{center}

\section{Dead Code Elimination}
\label{cr-dce}

Dead Code Elimination or \emph{DCE} is a compiler feature which removes unused code from the output. After typing, the compiler evaluates the DCE entry-points (usually the main-method) and recursively determines which fields and types are used. Used fields are marked accordingly and unmarked fields are then removed from their classes.

DCE has three modes which are set when invoking the command line:

\begin{description}
	\item[-dce std:] Only classes in the Haxe Standard Library are affected by DCE. This is the default setting on all targets.
	\item[-dce no:] No DCE is performed.
	\item[-dce full:] All classes are affected by DCE.
\end{description}
The DCE-algorithm works well with typed code, but may fail when \tref{dynamic}{types-dynamic} or \tref{reflection}{std-reflection} is involved. This may require explicit marking of fields or classes as being used by attributing the following metadata:

\begin{description}
	\item[\expr{@:keep}:] If used on a class, the class along with all fields is unaffected by DCE. If used on a field, that field is unaffected by DCE.
	\item[\expr{@:keepSub}:] If used on a class, it works like \expr{@:keep} on the annotated class as well as all subclasses.
	\item[\expr{@:keepInit}:] Usually, a class which had all fields removed by DCE (or is empty to begin with) is removed from the output. By using this metadata, empty classes are kept.
\end{description}

If a class needs to be marked with \expr{@:keep} from the command line instead of editing its source code, there is a compiler macro available for doing so: \expr{--macro keep('type dot path')} See the \href{http://api.haxe.org/haxe/macro/Compiler.html#keep}{haxe.macro.Compiler.keep API} for details of this macro. It will mark package, module or sub-type to be kept by DCE and includes them for compilation.
 
The compiler automatically defines the flag \expr{dce} with a value of either \expr{"std"}, \expr{"no"} or \expr{"full"} depending on the active mode. This can be used in \tref{conditional compilation}{lf-condition-compilation}.

\trivia{DCE-rewrite}{DCE was originally implemented in Haxe 2.07. This implementation considered a function to be used when it was explicitly typed. The problem with that was that several features, most importantly interfaces, would cause all class fields to be typed in order to verify type-safety. This effectively subverted DCE completely, prompting the rewrite for Haxe 2.10.}

\trivia{DCE and try.haxe.org}{DCE for the \type{Javascript} target saw vast improvements when the website \url{http://try.haxe.org} was published. Initial reception of the generated \target{Javascript} code was mixed, leading to a more fine-grained selection of which code to eliminate.}

\section{Completion}
\label{cr-completion}

Because of the high number of Haxe features and its powerful type inference, \href{http://haxe.org/documentation/introduction/editors-and-ides.html}{IDE and code editors} cannot easily handle completion by parsing the Haxe files. Haxe provides completion support for IDEs directly built in the compiler thanks to the \ic{--display} commandline parameter.

Let's have a look at the following example :
\begin{lstlisting}
class Test {
    public static function main() {
        trace("Hello".|
    }
}
\end{lstlisting}

The vertical bar indicates the cursor position after the dot has been pressed. At this time, it is the job of the IDE to call the Haxe compiler with usual compilation parameters, plus an additional one \ic{--display Test.hx@73}.

This parameter determines the file in which we want some completion and the byte position of the cursor in the file. In the example given, you should get 73 if you count characters with windows CRLF lines ending.


Haxe will perform all the parsing and typing as it would do for normal compilation, except that it will not generate any code. If it reaches the byte 73 in the file \ic{Test.hx} during compilation, it will output the information about the type of the expression on the left of the dot.


In our case, that would be \type{String}. The exception being that in the case of an anonymous object or a class instance, the compiler will instead list the different fields in an XML and print them to a possible output:

\begin{lstlisting}
<list>
<i n="length"><t>Int</t><d>...</d></i>
<i n="charAt"><t>index : Int -> String</t><d>...</d></i>
<i n="charCodeAt"><t>index : Int -> Int</t><d>...</d></i>
<i n="indexOf">
  <t>value : String -> ?startIndex : Int -> Int</t>
  <d>...</d>
</i>
...
</list>
\end{lstlisting}

In that case, all public methods and fields of \type{String} are listed. This information can directly be used by the IDE to provide code hints and completion.

\paragraph{Functions completion}
This completion mechanism works with both dot and opening parenthesis, so you can get type information about fields lists and function call arguments types:

\begin{lstlisting}
class Test {
    public static function main() {
        trace("Hello".split(|
    }
}
\end{lstlisting}

This will give you the following result: \expr{<type>delimiter : String -> Array<String></type>} \_(please note that the content of the type is not html-escaped in the real output)\_

\paragraph{Package completion}
It also works with packages by scanning the .hx files available in the classpath:

\begin{lstlisting}
import haxe.|
Will return :

<list>
    <i n="BaseCode"><t></t><d></d></i>
    <i n="EnumFlags"><t></t><d></d></i>
    ...
    <i n="io"><t></t><d></d></i>
    <i n="macro"><t></t><d></d></i>
    <i n="remoting"><t></t><d></d></i>
    ...
</list>
\end{lstlisting}

\paragraph{Error Handling}
When run in completion mode, the compiler will not display errors but instead try to ignore them or recover from them. 

If a not recoverable error occurs while getting completion, the Haxe compiler will print the error message instead of the completion output. You can then treat any not-XML output as an error message which prevents the completion.

\paragraph{Compilation cache server}
\since{2.09}

Get the best speed for both compilation and completion, you can use the \ic{--wait} commandline parameter to start a Haxe compilation server. You can also use \ic{-v} to have the server print the log. Here's an example:

\begin{lstlisting}
haxe -v --wait 6000
\end{lstlisting}

You can then connect to the Haxe server, send commandline parameters followed by a 0 byte and then read the response (either completion result or errors).

Use the \ic{--connect} commandline parameter to have Haxe send its compilation commands to the server instead of executing them directly :

\begin{lstlisting}
haxe --connect 6000 myproject.hxml
\end{lstlisting}

Please note that you can use \ic{--cwd} at the first sent commandline parameter to change the Haxe server's current working directory. Usually class paths and other files are relative to your project.

\paragraph{How it works}
The compilation server will cache the following things:

\begin{description}
	\item[parsed files] the files will only get parsed again if they are modified or if there was a parse error
	\item[haxelib calls] the previous results of haxelib calls will be reused (only for completion : they are ignored when doing a compilation)
	\item[typed modules] compilation modules will be cached after a successful compilation and can be reused in later compilation/completions if none of their dependencies have been modified
\end{description}

You can get precise reading of the times spent by the compiler and how using the compilation server affects it by adding the \ic{--times} command line.

\paragraph{Protocol}
As the following Haxe/Neko example shows, you can simply connect on the server port and send all commands (one per line) ending with a 0 binary char. You can then read the results.

Macros and other commands can log events which are not errors. From the command line we can see the difference between what is printed on \ic{stdout} and what is print on \ic{stderr}. This is not the case in socket mode. In order to differentiate between the two, log messages (not errors) are prefixed with a \ic{\\x01} character and all newline-characters in the message are replaced by the same \ic{\\x01} character.
warnings and other messages can also be considered errors, but are not fatal ones. If a fatal error occurred, we will send a single \ic{\\x02} message-line
Here's some code that will treat connect to the server and handle the protocol details :

\begin{lstlisting}
class Test {
    static function main() {
		var newline = "\textbackslash\ n";
        var s = new neko.net.Socket();
        s.connect(new neko.net.Host("127.0.0.1"),6000);
        s.write("--cwd /my/project" + newline);
        s.write("myproject.hxml" + newline);
        s.write("\textbackslash\ 000");
		
        var hasError = false;
        for (line in s.read().split(newline))
		{
            switch (line.charCodeAt(0)) {
				case 0x01: 
					neko.Lib.print(line.substr(1).split("\textbackslash\ x01").join(newline));
				case 0x02: 
					hasError = true;
				default: 
					neko.io.File.stderr().writeString(line + newline);
            }
		}
        if (hasError) neko.Sys.exit(1);
    }
}
\end{lstlisting}

\paragraph{Effect on macros}
The compilation server can have some side effects on \tref{macro execution}{macro}.

\subsection{Field Access}
\label{cr-completion-field-access}

\subsection{Call Arguments}
\label{cr-completion-call-arguments}

\subsection{Usage}
\label{cr-completion-usage}

\subsection{Position}
\label{cr-completion-position}

\subsection{Toplevel}
\label{cr-completion-toplevel}

\section{Resources}
\label{cr-resources}
\flag{fold}{true}

Haxe provides a simple resource embedding system that can be used for embedding files directly into the compiled application.

While it may be not optimal to embed large assets such as images or music in the application file, it comes in very handy for embedding smaller resources like configuration or XML data.

\subsection{Embedding resources}
\label{cr-resources-embed}

External files are embedded using the \emph{-resource} compiler argument:

\todo{what to use for listing of non-haxe code like hxml?}
\begin{lstlisting}
-resource hello_message.txt@welcome
\end{lstlisting}

The string after the \emph{@} symbol is the \emph{resource identifier} which is used in the code for retrieving the resource. If it is omitted (together with the \emph{@} symbol) then the file name will become the resource identifier.

\subsection{Retrieving text resources}
\label{cr-resources-getString}

To retrieve the content of an embedded resource we use the static method \emph{getString} of \type{haxe.Resource}, passing a \emph{resource identifier} to it:

\haxe{assets/ResourceGetString.hx}

The code above will display the content of the \emph{hello_message.txt} file that we included earlier using \emph{welcome} as the identifier.

\subsection{Retrieving binary resources}
\label{cr-resources-getBytes}

While it's not recommended to embed large binary files in the application, it still may be useful to embed binary data. The binary representation of an embedded resource can be accessed using the static method \emph{getBytes} of \type{haxe.Resource}:

\haxe{assets/ResourceGetBytes.hx}

The return type of \emph{getBytes} method is \type{haxe.io.Bytes}, which is an object providing access to individual bytes of the data.

\subsection{Implementation details}
\label{cr-resources-impl}

Haxe uses the target platform's native resource embedding if there is one, otherwise it provides its own implementation.

\begin{itemize}
\item \emph{Flash} resources are embedded as ByteArray definitions
\item \emph{C\#} resources are included in the compiled assembly
\item \emph{Java} resources are packed in the resulting JAR file
\item \emph{C++} resources are stored in global byte array constants.
\item \emph{JavaScript} resources are serialized in Haxe serialization format and stored in a static field of \type{haxe.Resource} class.
\item \emph{Neko} resources are stored as strings in a static field of \type{haxe.Resource} class.
\end{itemize}



\section{Runtime Type Information}
\label{cr-rtti}

The Haxe compiler generates runtime type information (RTTI) for classes that are annotated or extend classes that are annotated with the \expr{:rtti} metadata. This information is stored as a XML string in a static field \expr{__rtti} and can be processed through \type{haxe.rtti.XmlParser}. The resulting structure is described in \Fullref{cr-rtti-structure}.

\since{3.2.0}

The type \type{haxe.rtti.Rtti} has been introduced in order to simplify working with RTTI. Retrieving this information is now very easy:

\haxe{assets/RttiUsage.hx}

\subsection{RTTI structure}
\label{cr-rtti-structure}

\paragraph{General type information}

\begin{description}
	\item[path:] The \tref{type path}{define-type-path} of the type.
	\item[module:] The type path of the \tref{module}{define-module} containing the type.
	\item[file:] The full slash path of the .hx file containing the type. This might be \expr{null} in case there is no such file, e.g. if the type is defined through a \tref{macro}{macro}.
	\item[params:] An array of strings representing the names of the \tref{type parameters}{type-system-type-parameters} the type has. As of Haxe 3.2.0, this does not include the \tref{constraints}{type-system-type-parameter-constraints}.
	\item[doc:] The documentation of the type. This information is only available if the \tref{compiler flag}{define-compiler-flag} \expr{-D use_rtti_doc} was in place. Otherwise, or if the type has no documentation, the value is \expr{null}.
	\item[isPrivate:] Whether or not the type is \tref{private}{define-private-type}.
	\item[platforms:] A list of strings representing the targets where the type is available.
	\item[meta:] The meta data the type was annotated with.
\end{description}
	
\paragraph{Class type information}
\label{cr-rtti-class-type-information}

\begin{description}
	\item[isExtern:] Whether or not the class is \tref{extern}{lf-externs}.
	\item[isInterface:] Whether or not the class is actually an \tref{interface}{types-interfaces}.
	\item[superClass:] The class' parent class defined by its type path and list of type parameters.
	\item[interfaces:] The list of interfaces defined by their type path and list of type parameters.
	\item[fields:] The list of member \tref{class fields}{class-field}, described in \Fullref{cr-rtti-class-field-information}.
	\item[statics:] The list of static class fields, described in \Fullref{cr-rtti-class-field-information}.
	\item[tdynamic:] The type which is \tref{dynamically implemented}{types-dynamic-implemented} by the class or \expr{null} if no such type exists.
\end{description}

\paragraph{Enum type information}

\begin{description}
	\item[isExtern:] Whether or not the enum is \tref{extern}{lf-externs}.
	\item[constructors:] The list of enum constructors.
\end{description}

\paragraph{Abstract type information}

\begin{description}
	\item[to:] An array containing the defined \tref{implicit to casts}{types-abstract-implicit-casts}.
	\item[from:] An array containing the defined \tref{implicit from casts}{types-abstract-implicit-casts}.
	\item[impl:] The \tref{class type information}{cr-rtti-class-type-information} of the implementing class.
	\item[athis:] The \tref{underlying type}{define-underlying-type} of the abstract.
\end{description}
	
	
\paragraph{Class field information}
\label{cr-rtti-class-field-information}

\begin{description}
	\item[name:] The name of the field.
	\item[type:] The type of the field.
	\item[isPublic:] Whether or not the field is \tref{public}{class-field-visibility}.
	\item[isOverride:] Whether or not the field \tref{overrides}{class-field-override} another field.
	\item[doc:] The documentation of the field. This information is only available if the \tref{compiler flag}{define-compiler-flag} \expr{-D use_rtti_doc} was in place. Otherwise, or if the field has no documentation, the value is \expr{null}.
	\item[get:] The \tref{read access behavior}{define-read-access} of the field.
	\item[set:] The \tref{write access behavior}{define-write-access} of the field.
	\item[params:] An array of strings representing the names of the \tref{type parameters}{type-system-type-parameters} the field has. As of Haxe 3.2.0, this does not include the \tref{constraints}{type-system-type-parameter-constraints}.
	\item[platforms:] A list of strings representing the targets where the field is available.
	\item[meta:] The meta data the field was annotated with.
	\item[line:] The line number where the field is defined. This information is only available if the field has an expression. Otherwise the value is \expr{null}.
	\item[overloads:] The list of available overloads for the fields or \expr{null} if no overloads exists.
\end{description}

\paragraph{Enum constructor information}
\label{cr-rtti-enum-constructor-information}

\begin{description}
	\item[name:] The name of the constructor.
	\item[args:] The list of arguments the constructor has or \expr{null} if no arguments are available.
	\item[doc:] The documentation of the constructor. This information is only available if the \tref{compiler flag}{define-compiler-flag} \expr{-D use_rtti_doc} was in place. Otherwise, or if the constructor has no documentation, the value is \expr{null}.
	\item[platforms:] A list of strings representing the targets where the constructor is available.
	\item[meta:] The meta data the constructor was annotated with.
\end{description}
